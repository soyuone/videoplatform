#Servlet的生命周期？ init(),destroy()方法具体什么时候调用？
   1.创建Servlet实例 (创建Servlet实例有两个时机：客户端第一次请求某个Servlet时或web应用启动时；实例的创建及销毁都不是由程序员决定，而是由web容器进行控制)
   2.web容器调用Servlet的init方法，对Servlet初始化 
   3.容器调用service/doPost/doGet方法处理响应用户请求 
   4.web容器决定销毁Servlet时，先调用Servlet的destroy方法，通常在关闭web应用时销毁Servlet.
  
   Filter,Servlet调用流程：
	    web应用启动时，调用Filter init方法对Filter初始化
	           用户第一次发送请求后创建Servlet实例，调用Servlet init方法对其进行初始化
	           调用Filter doFilter方法在HttpServletRequest到达Servlet进行预处理
	           调用Servlet service方法对用户请求进行处理
	           调用Filter doFilter方法在HttpServletResponse到达客户端之前进行后处理
	    web应用关闭时，调用Servlet destroy方法销毁Servlet实例
	    web应用关闭时，调用Filter destroy方法销毁Filter


 web服务器负责接收客户端请求，每当接收到客户端连接请求后 web服务器应该使用单独的线程为该客户端提供服务：接收请求数据，送回响应数据。最新版的Tomcat已经不需要对
   每个用户请求都启用单独的线程、使用普通I/O读取用户请求的数据，最新版的Tomcat使用的是异步IO，具有更高的性能?


 POST请求传送的参数以及对应的值放在HTML HEADER中传输，@Responsebody URIEncoding？


 session机制用于保存客户端的状态信息，这些信息将会保存到web服务器的硬盘上；session里的属性值必须是可序列化的，否则将会引发不可序列化的异常?

 
 OpenSessionInViewFilter工作原理?


#性能优化之Hibernate Session、SessionFactory级别的缓存? 查询缓存？
   Hibernate包含两个级别的缓存：默认总是启动的Session级别的一级缓存，可选的SessionFactory级别的二级缓存;Session级别的一级缓存是局部缓存，只对当前
   Session有效，SessionFactory级别的二级缓存是全局缓存，对所有的Session都有效.
   
        开启Hibernate二级缓存需要：1.设置启用二级缓存 2.设置二级缓存的实现类
    
        当应用保存持久化实体、修改持久化实体时，Session并不会把这种改变flush到数据库，而是缓存在当前Session的一级缓存中，除非程序显式调用Session的flush方法或
        程序关闭Session时才会把这些改变一次性的fulsh到底层数据库——通过这种缓存可以减少与数据库的交互，从而提高数据库访问性能.
           
   SessionFactory级别的二级缓存是全局性的，所有Session都共享此二级缓存，默认是关闭的，必须由程序显式开启。一旦在应用中开启了二级缓存，当Session需要抓取
        数据时，Session将会先查找一级缓存，再查找二级缓存，只有当一级和二级缓存中都没有需要抓取的数据时，才会去查找底层数据库.
        一旦开启了二级缓存，而且设置了对某个持久化实体类启用缓存，SessionFactory就会缓存应用访问过的该实体类的每个对象，除非缓存的数据超过缓存空间.
        
       一级、二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果相对普通属性进行缓存，可以使用查询缓存.只有经常使用相同的查询语句，并且使用相同的查询参数才能通过查询缓存获得好处,
       查询缓存的生命周期直到属性被修改了为止.然而通常情况下使用查询缓存并不能提高性能，反而会降低性能，因此慎用.
      

#Hibernate延迟加载、Session关闭、openSession、getCurrentSession、线程、事务、Filter、ThreadLocal?
           

 